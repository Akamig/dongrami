{
  "version": 3,
  "sources": ["../index.ts", "../v3.ts"],
  "sourcesContent": ["import * as secp from \"@noble/secp256k1\";\nimport { Account } from \"@planetarium/sign\";\nimport { ethers } from \"ethers\";\nimport { decipherV3, rawPrivateKeyToV3, V3Keystore } from \"./v3\";\n\n/**\n * account-web\n *\n * Gets Web3 Secret Storage formatted keyfile as key source and creates account.\n * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n *\n */\n\nexport function getAccountFromV3(\n  V3Keystore: string,\n  passphrase: string\n): Account {\n  decipherV3(V3Keystore, passphrase);\n\n  return {\n    VERSION: 0,\n    async getPublicKey(isCompressed: boolean = true) {\n      const wallet = new ethers.Wallet(decipherV3(V3Keystore, passphrase));\n      const publicKey = secp.utils.hexToBytes(wallet.publicKey.substring(2));\n\n      return secp.Point.fromHex(publicKey).toRawBytes(isCompressed);\n    },\n    sign(hash) {\n      return secp.sign(\n        hash,\n        decipherV3(V3Keystore, passphrase).privateKey.substring(2)\n      );\n    },\n  };\n}\n\nexport { decipherV3, rawPrivateKeyToV3, V3Keystore };\n", "import { ethers } from \"ethers\";\n\n// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\nexport interface V3Keystore {\n  crypto: {\n    cipher: string;\n    cipherparams: {\n      iv: string;\n    };\n    ciphertext: string;\n    kdf: string;\n    kdfparams: KDFParamsOut;\n    mac: string;\n  };\n  id: string;\n  version: number;\n  address: string;\n}\n\ninterface PBKDFParamsOut {\n  c: number;\n  dklen: number;\n  prf: string;\n  salt: string;\n}\n\ninterface ScryptKDFParamsOut {\n  dklen: number;\n  n: number;\n  p: number;\n  r: number;\n  salt: string;\n}\n\ntype KDFParamsOut = ScryptKDFParamsOut | PBKDFParamsOut;\n\nexport function decipherV3(\n  input: string | V3Keystore,\n  password: string,\n  nonStrict = false\n) {\n  const json =\n    typeof input === \"object\"\n      ? JSON.stringify(input)\n      : nonStrict\n      ? input.toLowerCase()\n      : input;\n  const decrypted = ethers.Wallet.fromEncryptedJsonSync(json, password);\n  return decrypted;\n}\n\nexport async function rawPrivateKeyToV3(\n  privateKey: string,\n  passphrase: string\n) {\n  try {\n    const wallet = new ethers.Wallet(privateKey);\n    const encryptedJson = await wallet.encrypt(passphrase);\n    return encryptedJson;\n  } catch (e) {\n    console.error(e);\n  }\n}\n"],
  "mappings": "AAAA,UAAYA,MAAU,mBAEtB,OAAS,UAAAC,MAAc,SCFvB,OAAS,UAAAC,MAAc,SAoChB,SAASC,EACdC,EACAC,EACAC,EAAY,GACZ,CACA,IAAMC,EACJ,OAAOH,GAAU,SACb,KAAK,UAAUA,CAAK,EACpBE,EACAF,EAAM,YAAY,EAClBA,EAEN,OADkBF,EAAO,OAAO,sBAAsBK,EAAMF,CAAQ,CAEtE,CAEA,eAAsBG,EACpBC,EACAC,EACA,CACA,GAAI,CAGF,OADsB,MADP,IAAIR,EAAO,OAAOO,CAAU,EACR,QAAQC,CAAU,CAEvD,OAASC,EAAP,CACA,QAAQ,MAAMA,CAAC,CACjB,CACF,CDjDO,SAASC,EACdC,EACAC,EACS,CACT,OAAAC,EAAWF,EAAYC,CAAU,EAE1B,CACL,QAAS,EACT,MAAM,aAAaE,EAAwB,GAAM,CAC/C,IAAMC,EAAS,IAAIC,EAAO,OAAOH,EAAWF,EAAYC,CAAU,CAAC,EAC7DK,EAAiB,QAAM,WAAWF,EAAO,UAAU,UAAU,CAAC,CAAC,EAErE,OAAY,QAAM,QAAQE,CAAS,EAAE,WAAWH,CAAY,CAC9D,EACA,KAAKI,EAAM,CACT,OAAY,OACVA,EACAL,EAAWF,EAAYC,CAAU,EAAE,WAAW,UAAU,CAAC,CAC3D,CACF,CACF,CACF",
  "names": ["secp", "ethers", "ethers", "decipherV3", "input", "password", "nonStrict", "json", "rawPrivateKeyToV3", "privateKey", "passphrase", "e", "getAccountFromV3", "V3Keystore", "passphrase", "decipherV3", "isCompressed", "wallet", "ethers", "publicKey", "hash"]
}
